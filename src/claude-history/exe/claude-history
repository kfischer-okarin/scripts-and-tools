#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative "../lib/claude_history"
require "thor"

module ClaudeHistory
  class CLI < Thor
    PROJECTS_PATH = File.expand_path("~/.claude/projects")

    desc "projects", "List all projects with last updated timestamp"
    def projects
      history = History.new(PROJECTS_PATH)
      sorted = history.projects.sort_by { |p| p.last_updated_at || Time.at(0) }.reverse

      print_projects_table(sorted)
    end

    desc "sessions", "List all sessions in a project"
    method_option :project, type: :string, required: true, desc: "Project ID"
    method_option :limit, type: :numeric, default: 20, desc: "Number of sessions to show"
    method_option :all_threads, type: :boolean, default: false, desc: "Show all threads per session"
    method_option :full_ids, type: :boolean, default: false, desc: "Show full session/thread IDs"
    def sessions
      history = History.new(PROJECTS_PATH)
      all_sessions = history.sessions(project_id: options[:project])
      sessions_list = all_sessions.first(options[:limit])

      print_sessions_table(sessions_list, total: all_sessions.size, show_threads: options[:all_threads], full_ids: options[:full_ids])
    end

    private

    def print_projects_table(projects)
      return puts "No projects found." if projects.empty?

      # Calculate column widths
      id_width = [projects.map { |p| p.id.length }.max, "PROJECT ID".length].max
      time_width = ["LAST UPDATED AT".length, "2025-12-23 00:07:04".length].max

      # Print header
      puts format("%-#{id_width}s  %-#{time_width}s", "PROJECT ID", "LAST UPDATED AT")
      puts "-" * (id_width + 2 + time_width)

      # Print rows
      projects.each do |project|
        timestamp = project.last_updated_at&.getlocal&.strftime("%Y-%m-%d %H:%M:%S") || "N/A"
        puts format("%-#{id_width}s  %-#{time_width}s", project.id, timestamp)
      end
    end

    THREAD_PREFIX = "  └─ "

    def self.green(text)
      "\e[32m#{text}\e[0m"
    end

    def self.grey(text)
      "\e[90m#{text}\e[0m"
    end

    SESSION_COLUMNS = [
      {
        name: "SESSION ID",
        colorize: ->(id) {
          if id.start_with?(THREAD_PREFIX)
            THREAD_PREFIX + green(id[THREAD_PREFIX.length..-1])
          else
            green(id)
          end
        }
      },
      {
        name: "SUMMARY",
        width: 50
      },
      {
        name: "LAST UPDATED AT",
        colorize: method(:grey)
      }
    ]

    def print_sessions_table(sessions, total:, show_threads:, full_ids:)
      return puts "No sessions found." if sessions.empty?

      puts "Showing #{sessions.size} of #{total} sessions"
      puts "Tip: Use --all-threads to show individual conversation threads" unless show_threads
      puts

      rows = []
      sessions.each do |session|
        rows << [
          full_ids ? session.id : truncate_id(session.id),
          truncate_summary(session.threads.first&.summary, 50),
          format_timestamp(session.last_updated_at),
        ]

        next unless show_threads

        session.threads.each do |thread|
          id = full_ids ? thread.id : truncate_id(thread.id)
          rows << [
            "#{THREAD_PREFIX}#{id}",
            truncate_summary(thread.summary, 50),
            format_timestamp(thread.last_updated_at)
          ]
        end
      end

      print_table(rows, columns: SESSION_COLUMNS)
    end

    def print_table(rows, columns:)
      column_widths = columns.each_with_index.map { |col, idx|
        if col[:width]
          col[:width]
        else
          value_lengths = rows.map { |row| row[idx].length }
          [value_lengths.max, col[:name].length].max
        end
      }

      headers = columns.each_with_index.map { |col, idx|
        col[:name].ljust(column_widths[idx])
      }
      header_line = headers.join("  ")
      puts header_line
      puts "-" * header_line.length

      # Print rows
      rows.each do |row|
        printed_values = columns.each_with_index.map { |col, idx|
          colorize = col[:colorize] || ->(text) { text }
          colorize.call(row[idx].ljust(column_widths[idx]))
        }
        puts printed_values.join("  ")
      end
    end

    def format_timestamp(timestamp)
      timestamp&.getlocal&.strftime("%Y-%m-%d %H:%M:%S") || "N/A"
    end

    def truncate_summary(text, max_length)
      return "" if text.nil? || text.empty?

      first_line = text.lines.first&.strip || ""
      first_line.length > max_length ? first_line[0...max_length - 3] + "..." : first_line
    end

    def truncate_id(id, length = 8)
      id[0, length]
    end
  end
end

ClaudeHistory::CLI.start(ARGV)
